package lambdamu

import scala.collection.mutable
import scala.util.parsing.combinator.JavaTokenParsers

// --- AST ---
enum Expr:
  case Var(name: String)
  case Lam(param: String, body: Expr)
  case App(fun: Expr, arg: Expr)
  case Freeze(alpha: String, expr: Expr)
  case Mu(alpha: String, expr: Expr)

object LambdaMu:
  private val env = mutable.Map.empty[String, Expr]

  // Resolve globals
  def resolve(e: Expr): Expr = e match
    case Expr.Var(n) if env.contains(n) => resolve(env(n))
    case Expr.Lam(x,b)                  => Expr.Lam(x, resolve(b))
    case Expr.App(f,a)                  => Expr.App(resolve(f), resolve(a))
    case Expr.Freeze(a,x)               => Expr.Freeze(a, resolve(x))
    case Expr.Mu(a,x)                   => Expr.Mu(a, resolve(x))
    case other                          => other

  // Substitution
  def substU(x: String, v: Expr, e: Expr): Expr = e match
    case Expr.Var(y) if y == x => v
    case Expr.Lam(y,b) if y == x => Expr.Lam(y,b)
    case Expr.Lam(y,b) => Expr.Lam(y, substU(x,v,b))
    case Expr.App(f,a) => Expr.App(substU(x,v,f), substU(x,v,a))
    case Expr.Freeze(a,x) => Expr.Freeze(a, substU(x,v,x))
    case Expr.Mu(a,x) => Expr.Mu(a, substU(x,v,x))
    case other => other

  // Rename continuation names
  def renameN(b:String,a:String,e:Expr):Expr = e match
    case Expr.Var(x)         => Expr.Var(x)
    case Expr.Lam(x,bod)     => Expr.Lam(x, renameN(b,a,bod))
    case Expr.App(f,arg)     => Expr.App(renameN(b,a,f), renameN(b,a,arg))
    case Expr.Freeze(g,w)    => Expr.Freeze(if g==b then a else g, renameN(b,a,w))
    case Expr.Mu(g,u) if g==b=> Expr.Mu(g,u)
    case Expr.Mu(g,u)        => Expr.Mu(g, renameN(b,a,u))

  // App in continuation
  def appN(b:String, v:Expr, e:Expr):Expr = e match
    case Expr.Var(x) => Expr.Var(x)
    case Expr.Lam(x,bod) => Expr.Lam(x, appN(b,v,bod))
    case Expr.App(f,a) => Expr.App(appN(b,v,f), appN(b,v,a))
    case Expr.Freeze(g,w) if g==b => Expr.Freeze(g, Expr.App(appN(b,v,w),v))
    case Expr.Freeze(g,w) => Expr.Freeze(g, appN(b,v,w))
    case Expr.Mu(g,u) if g==b => Expr.Mu(g,u)
    case Expr.Mu(g,u) => Expr.Mu(g, appN(b,v,u))

  // One-step reductions including idempotence
  def reduce0(e: Expr): (Expr,Boolean) = e match
    case Expr.Freeze(a1, Expr.Freeze(a2,x)) if a1==a2 =>
      (Expr.Freeze(a1,x), true)
    case Expr.App(Expr.Lam(x,u),v) =>
      (substU(x,v,u), true)
    case Expr.App(Expr.Mu(b,u),v) =>
      (Expr.Mu(b, appN(b,v,u)), true)
    case Expr.Freeze(a, Expr.Mu(b,u)) =>
      (renameN(b,a,u), true)
    case Expr.Mu(a, Expr.Freeze(b,x)) if a==b =>
      (x, true)
    case _ => (e,false)

  // Recursive one-step
  def reduce1(e: Expr):(Expr,Boolean) = e match
    case v @ Expr.Var(_) => (v,false)
    case Expr.Lam(x,b) =>
      val (b1,c1)=reduce1(b); val (r,c2)=reduce0(Expr.Lam(x,b1))
      (r, c1||c2)
    case Expr.App(f,a) =>
      val (f1,c1)=reduce1(f); val (a1,c2)=reduce1(a)
      val (r,c3)=reduce0(Expr.App(f1,a1))
      (r, c1||c2||c3)
    case Expr.Freeze(a,x) =>
      val (x1,c1)=reduce1(x); val (r,c2)=reduce0(Expr.Freeze(a,x1))
      (r, c1||c2)
    case Expr.Mu(a,x) =>
      val (x1,c1)=reduce1(x); val (r,c2)=reduce0(Expr.Mu(a,x1))
      (r, c1||c2)

  // Full normalize
  @annotation.tailrec 
  def reduce(e:Expr):Expr = reduce1(e) match
    case (e1,true) => reduce(e1)
    case (e1,false)=> e1

  // Trace
  def evalSteps(e:Expr):List[Expr] =
    var buf=List(e); var c=e; var cont=true
    while cont do
      val (n,ch)=reduce1(c)
      if ch then buf ::= n; c=n else cont=false
    buf.reverse

  // Pretty-print with alpha-renaming
  def pretty(e:Expr):String =
    def loop(e:Expr, env:Map[String,String], used:Set[String]):(String,Set[String]) = e match
      case Expr.Var(n) => (env.getOrElse(n,n),used)
      case Expr.Lam(x,b) =>
        var fresh=x; var idx=0
        while used(fresh) do { idx+=1; fresh=s"$x$idx" }
        val (bs,used2)=loop(b,env+(x->fresh),used+fresh)
        (s"λ$fresh.$bs",used2)
      case Expr.App(f,a) =>
        val (fs,u2)=loop(f,env,used); val (as,u3)=loop(a,env,u2)
        (s"$fs $as",u3)
      case Expr.Freeze(a,x) =>
        val (xs,u2)=loop(x,env,used); (s"[$a]$xs",u2)
      case Expr.Mu(a,x) =>
        val (xs,u2)=loop(x,env,used); (s"μ$a.$xs",u2)
    loop(e,Map(),Set())._1

  // Parser
  object Parser extends JavaTokenParsers:
    def identifier = "[a-zA-Z_]\\w*".r
    def lam = "\\" ~> identifier ~ ("."~>expr) ^^ { case x~e => Expr.Lam(x,e) }
    def mu  = ("mu" | "μ") ~> identifier ~ ("."~>expr) ^^ { case a~e => Expr.Mu(a,e) }
    def freeze = "["~>identifier<~"]"~expr ^^ { case a~e => Expr.Freeze(a,e) }
    def parens = "("~>expr<~")"
    def term = lam | mu | freeze | parens | identifier ^^ Expr.Var
    def app = rep1(term) ^^ { case t::ts => ts.foldLeft(t)(Expr.App) }
    def expr = app
    def parse(in:String) = parseAll(expr,in).getOrElse(
      throw IllegalArgumentException("Parse error")
    )

  // REPL helper
  private def handleLine(line:String):Unit =
    val l=line.trim
    if l.startsWith("let ") && l.contains("=") then
      val Array(_,n,r)=l.split("=",2).map(_.trim.stripPrefix("let "))
      try { env(n)=resolve(Parser.parse(r)); println(s"Defined $n.") }
      catch { case e => println(s"Define error: ${e.getMessage}") }
    else if l.startsWith("load \"")&&l.endsWith("\"") then
      val fn=l.stripPrefix("load \"").stripSuffix("\"")
      try scala.io.Source.fromFile(fn).getLines().foreach { ln =>
        if ln.trim.nonEmpty then
          println(s"> ${ln.trim}"); handleLine(ln)
      }
      catch { case e => println(s"Could not load '$fn': ${e.getMessage}") }
    else if l.nonEmpty then
      try evalSteps(resolve(Parser.parse(l))).zipWithIndex.foreach{(e,i)=>
        println(s"[$i] ${pretty(e)}") }
      catch { case e => println(s"Error: ${e.getMessage}") }

  /** Read-Eval-Print Loop */
  def repl():Unit = {
    println("λμ-Calculus REPL (Scala 3). Type :q to quit.")
    var cont=true
    while cont do
      print("> "); Console.flush()
      scala.io.StdIn.readLine() match
        case null|":q"=> cont=false
        case in       => handleLine(in)
    println("Goodbye.")
  }

@main def runRepl():Unit = LambdaMu.repl()

